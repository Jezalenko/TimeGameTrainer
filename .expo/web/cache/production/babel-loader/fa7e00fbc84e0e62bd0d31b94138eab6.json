{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{PermissionStatus,createPermissionHook,EventEmitter,Platform}from'expo-modules-core';import{_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS}from\"../AV\";import ExponentAV from\"../ExponentAV\";import{isAudioEnabled,throwIfAudioIsDisabled}from\"./AudioAvailability\";import{RecordingOptionsPresets}from\"./RecordingConstants\";import{Sound}from\"./Sound\";var _recorderExists=false;var eventEmitter=Platform.OS==='android'?new EventEmitter(ExponentAV):null;export function getPermissionsAsync(){return _getPermissionsAsync.apply(this,arguments);}function _getPermissionsAsync(){_getPermissionsAsync=_asyncToGenerator(function*(){return ExponentAV.getPermissionsAsync();});return _getPermissionsAsync.apply(this,arguments);}export function requestPermissionsAsync(){return _requestPermissionsAsync.apply(this,arguments);}function _requestPermissionsAsync(){_requestPermissionsAsync=_asyncToGenerator(function*(){return ExponentAV.requestPermissionsAsync();});return _requestPermissionsAsync.apply(this,arguments);}export var usePermissions=createPermissionHook({getMethod:getPermissionsAsync,requestMethod:requestPermissionsAsync});export var Recording=function(){function Recording(){var _this=this;_classCallCheck(this,Recording);this._subscription=null;this._canRecord=false;this._isDoneRecording=false;this._finalDurationMillis=0;this._uri=null;this._onRecordingStatusUpdate=null;this._progressUpdateTimeoutVariable=null;this._progressUpdateIntervalMillis=_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;this._options=null;this._cleanupForUnloadedRecorder=function(){var _ref=_asyncToGenerator(function*(finalStatus){var _finalStatus$duration;_this._canRecord=false;_this._isDoneRecording=true;_this._finalDurationMillis=(_finalStatus$duration=finalStatus==null?void 0:finalStatus.durationMillis)!=null?_finalStatus$duration:0;_recorderExists=false;if(_this._subscription){_this._subscription.remove();_this._subscription=null;}_this._disablePolling();return yield _this.getStatusAsync();});return function(_x){return _ref.apply(this,arguments);};}();this._pollingLoop=_asyncToGenerator(function*(){if(isAudioEnabled()&&_this._canRecord&&_this._onRecordingStatusUpdate!=null){_this._progressUpdateTimeoutVariable=setTimeout(_this._pollingLoop,_this._progressUpdateIntervalMillis);try{yield _this.getStatusAsync();}catch(_unused){_this._disablePolling();}}});this.getStatusAsync=_asyncToGenerator(function*(){if(_this._canRecord){return _this._performOperationAndHandleStatusAsync(function(){return ExponentAV.getAudioRecordingStatus();});}var status={canRecord:false,isRecording:false,isDoneRecording:_this._isDoneRecording,durationMillis:_this._finalDurationMillis};_this._callOnRecordingStatusUpdateForNewStatus(status);return status;});}_createClass(Recording,[{key:\"_disablePolling\",value:function _disablePolling(){if(this._progressUpdateTimeoutVariable!=null){clearTimeout(this._progressUpdateTimeoutVariable);this._progressUpdateTimeoutVariable=null;}}},{key:\"_enablePollingIfNecessaryAndPossible\",value:function _enablePollingIfNecessaryAndPossible(){if(isAudioEnabled()&&this._canRecord&&this._onRecordingStatusUpdate!=null){this._disablePolling();this._pollingLoop();}}},{key:\"_callOnRecordingStatusUpdateForNewStatus\",value:function _callOnRecordingStatusUpdateForNewStatus(status){if(this._onRecordingStatusUpdate!=null){this._onRecordingStatusUpdate(status);}}},{key:\"_performOperationAndHandleStatusAsync\",value:function(){var _performOperationAndHandleStatusAsync2=_asyncToGenerator(function*(operation){throwIfAudioIsDisabled();if(this._canRecord){var status=yield operation();this._callOnRecordingStatusUpdateForNewStatus(status);return status;}else{throw new Error('Cannot complete operation because this recorder is not ready to record.');}});function _performOperationAndHandleStatusAsync(_x2){return _performOperationAndHandleStatusAsync2.apply(this,arguments);}return _performOperationAndHandleStatusAsync;}()},{key:\"setOnRecordingStatusUpdate\",value:function setOnRecordingStatusUpdate(onRecordingStatusUpdate){this._onRecordingStatusUpdate=onRecordingStatusUpdate;if(onRecordingStatusUpdate==null){this._disablePolling();}else{this._enablePollingIfNecessaryAndPossible();}this.getStatusAsync();}},{key:\"setProgressUpdateInterval\",value:function setProgressUpdateInterval(progressUpdateIntervalMillis){this._progressUpdateIntervalMillis=progressUpdateIntervalMillis;this.getStatusAsync();}},{key:\"prepareToRecordAsync\",value:function(){var _prepareToRecordAsync=_asyncToGenerator(function*(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:RecordingOptionsPresets.LOW_QUALITY;throwIfAudioIsDisabled();if(_recorderExists){throw new Error('Only one Recording object can be prepared at a given time.');}if(this._isDoneRecording){throw new Error('This Recording object is done recording; you must make a new one.');}if(!options||!options.android||!options.ios){throw new Error('You must provide recording options for android and ios in order to prepare to record.');}var extensionRegex=/^\\.\\w+$/;if(!options.android.extension||!options.ios.extension||!extensionRegex.test(options.android.extension)||!extensionRegex.test(options.ios.extension)){throw new Error(\"Your file extensions must match \"+extensionRegex.toString()+\".\");}if(!this._canRecord){if(eventEmitter){this._subscription=eventEmitter.addListener('Expo.Recording.recorderUnloaded',this._cleanupForUnloadedRecorder);}var _yield$ExponentAV$pre=yield ExponentAV.prepareAudioRecorder(options),uri=_yield$ExponentAV$pre.uri,status=_yield$ExponentAV$pre.status;_recorderExists=true;this._uri=uri;this._options=options;this._canRecord=true;var currentStatus=_objectSpread(_objectSpread({},status),{},{canRecord:true});this._callOnRecordingStatusUpdateForNewStatus(currentStatus);this._enablePollingIfNecessaryAndPossible();return currentStatus;}else{throw new Error('This Recording object is already prepared to record.');}});function prepareToRecordAsync(){return _prepareToRecordAsync.apply(this,arguments);}return prepareToRecordAsync;}()},{key:\"getAvailableInputs\",value:function(){var _getAvailableInputs=_asyncToGenerator(function*(){return ExponentAV.getAvailableInputs();});function getAvailableInputs(){return _getAvailableInputs.apply(this,arguments);}return getAvailableInputs;}()},{key:\"getCurrentInput\",value:function(){var _getCurrentInput=_asyncToGenerator(function*(){return ExponentAV.getCurrentInput();});function getCurrentInput(){return _getCurrentInput.apply(this,arguments);}return getCurrentInput;}()},{key:\"setInput\",value:function(){var _setInput=_asyncToGenerator(function*(inputUid){return ExponentAV.setInput(inputUid);});function setInput(_x3){return _setInput.apply(this,arguments);}return setInput;}()},{key:\"startAsync\",value:function(){var _startAsync=_asyncToGenerator(function*(){return this._performOperationAndHandleStatusAsync(function(){return ExponentAV.startAudioRecording();});});function startAsync(){return _startAsync.apply(this,arguments);}return startAsync;}()},{key:\"pauseAsync\",value:function(){var _pauseAsync=_asyncToGenerator(function*(){return this._performOperationAndHandleStatusAsync(function(){return ExponentAV.pauseAudioRecording();});});function pauseAsync(){return _pauseAsync.apply(this,arguments);}return pauseAsync;}()},{key:\"stopAndUnloadAsync\",value:function(){var _stopAndUnloadAsync=_asyncToGenerator(function*(){var _stopResult;if(!this._canRecord){if(this._isDoneRecording){throw new Error('Cannot unload a Recording that has already been unloaded.');}else{throw new Error('Cannot unload a Recording that has not been prepared.');}}var stopResult;var stopError;try{stopResult=yield ExponentAV.stopAudioRecording();}catch(err){stopError=err;}if(Platform.OS==='web'&&((_stopResult=stopResult)==null?void 0:_stopResult.uri)!==undefined){this._uri=stopResult.uri;}yield ExponentAV.unloadAudioRecorder();var status=yield this._cleanupForUnloadedRecorder(stopResult);return stopError?Promise.reject(stopError):status;});function stopAndUnloadAsync(){return _stopAndUnloadAsync.apply(this,arguments);}return stopAndUnloadAsync;}()},{key:\"getURI\",value:function getURI(){return this._uri;}},{key:\"createNewLoadedSound\",value:function(){var _createNewLoadedSound=_asyncToGenerator(function*(){var initialStatus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var onPlaybackStatusUpdate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");return this.createNewLoadedSoundAsync(initialStatus,onPlaybackStatusUpdate);});function createNewLoadedSound(){return _createNewLoadedSound.apply(this,arguments);}return createNewLoadedSound;}()},{key:\"createNewLoadedSoundAsync\",value:function(){var _createNewLoadedSoundAsync=_asyncToGenerator(function*(){var initialStatus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};var onPlaybackStatusUpdate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(this._uri==null||!this._isDoneRecording){throw new Error('Cannot create sound when the Recording has not finished!');}return Sound.createAsync({uri:this._uri},initialStatus,onPlaybackStatusUpdate,false);});function createNewLoadedSoundAsync(){return _createNewLoadedSoundAsync.apply(this,arguments);}return createNewLoadedSoundAsync;}()}]);return Recording;}();Recording.createAsync=_asyncToGenerator(function*(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:RecordingOptionsPresets.LOW_QUALITY;var onRecordingStatusUpdate=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var progressUpdateIntervalMillis=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var recording=new Recording();if(progressUpdateIntervalMillis){recording._progressUpdateIntervalMillis=progressUpdateIntervalMillis;}recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);yield recording.prepareToRecordAsync(_objectSpread(_objectSpread({},options),{},{keepAudioActiveHint:true}));try{var status=yield recording.startAsync();return{recording:recording,status:status};}catch(err){recording.stopAndUnloadAsync();throw err;}});export{PermissionStatus};export*from\"./RecordingConstants\";export*from\"./Recording.types\";","map":{"version":3,"names":["PermissionStatus","createPermissionHook","EventEmitter","Platform","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","isAudioEnabled","throwIfAudioIsDisabled","RecordingOptionsPresets","Sound","_recorderExists","eventEmitter","OS","getPermissionsAsync","_getPermissionsAsync","apply","arguments","_asyncToGenerator","requestPermissionsAsync","_requestPermissionsAsync","usePermissions","getMethod","requestMethod","Recording","_this","_classCallCheck","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","_ref","finalStatus","_finalStatus$duration","durationMillis","remove","_disablePolling","getStatusAsync","_x","_pollingLoop","setTimeout","_unused","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","status","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","_createClass","key","value","clearTimeout","_enablePollingIfNecessaryAndPossible","_performOperationAndHandleStatusAsync2","operation","Error","_x2","setOnRecordingStatusUpdate","onRecordingStatusUpdate","setProgressUpdateInterval","progressUpdateIntervalMillis","_prepareToRecordAsync","options","length","undefined","LOW_QUALITY","android","ios","extensionRegex","extension","test","toString","addListener","_yield$ExponentAV$pre","prepareAudioRecorder","uri","currentStatus","_objectSpread","prepareToRecordAsync","_getAvailableInputs","getAvailableInputs","_getCurrentInput","getCurrentInput","_setInput","inputUid","setInput","_x3","_startAsync","startAudioRecording","startAsync","_pauseAsync","pauseAudioRecording","pauseAsync","_stopAndUnloadAsync","_stopResult","stopResult","stopError","stopAudioRecording","err","unloadAudioRecorder","Promise","reject","stopAndUnloadAsync","getURI","_createNewLoadedSound","initialStatus","onPlaybackStatusUpdate","console","warn","createNewLoadedSoundAsync","createNewLoadedSound","_createNewLoadedSoundAsync","createAsync","recording","keepAudioActiveHint"],"sources":["../../src/Audio/Recording.ts"],"sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport {\n  RecordingInput,\n  RecordingObject,\n  RecordingOptions,\n  RecordingStatus,\n} from './Recording.types';\nimport { RecordingOptionsPresets } from './RecordingConstants';\nimport { Sound, SoundObject } from './Sound';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\n/**\n * Checks user's permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\n/**\n * Asks the user to grant permissions for audio recording.\n * @return A promise that resolves to an object of type `PermissionResponse`.\n */\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [permissionResponse, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\n// @needsAudit\n/**\n * This class represents an audio recording. After creating an instance of this class, `prepareToRecordAsync`\n * must be called in order to record audio. Once recording is finished, call `stopAndUnloadAsync`. Note that\n * only one recorder is allowed to exist in the state between `prepareToRecordAsync` and `stopAndUnloadAsync`\n * at any given time.\n *\n * Note that your experience must request audio recording permissions in order for recording to function.\n * See the [`Permissions` module](/guides/permissions) for more details.\n *\n * Additionally, audio recording is [not supported in the iOS Simulator](/workflow/ios-simulator/#limitations).\n *\n * @example\n * ```ts\n * const recording = new Audio.Recording();\n * try {\n *   await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);\n *   await recording.startAsync();\n *   // You are now recording!\n * } catch (error) {\n *   // An error occurred!\n * }\n * ```\n *\n * @return A newly constructed instance of `Audio.Recording`.\n */\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  /**\n   * Creates and starts a recording using the given options, with optional `onRecordingStatusUpdate` and `progressUpdateIntervalMillis`.\n   *\n   * ```ts\n   * const { recording, status } = await Audio.Recording.createAsync(\n   *   options,\n   *   onRecordingStatusUpdate,\n   *   progressUpdateIntervalMillis\n   * );\n   *\n   * // Which is equivalent to the following:\n   * const recording = new Audio.Recording();\n   * await recording.prepareToRecordAsync(options);\n   * recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n   * await recording.startAsync();\n   * ```\n   *\n   * @param options Options for the recording, including sample rate, bitrate, channels, format, encoder, and extension. If no options are passed to,\n   * the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`. See below for details on `RecordingOptions`.\n   * @param onRecordingStatusUpdate A function taking a single parameter `status` (a dictionary, described in `getStatusAsync`).\n   * @param progressUpdateIntervalMillis The interval between calls of `onRecordingStatusUpdate`. This value defaults to 500 milliseconds.\n   *\n   * @example\n   * ```ts\n   * try {\n   *   const { recording: recordingObject, status } = await Audio.Recording.createAsync(\n   *     Audio.RecordingOptionsPresets.HIGH_QUALITY\n   *   );\n   *   // You are now recording!\n   * } catch (error) {\n   *   // An error occurred!\n   * }\n   * ```\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the following dictionary if creation succeeded.\n   */\n  static createAsync = async (\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<RecordingObject> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  /**\n   * Gets the `status` of the `Recording`.\n   * @return A `Promise` that is resolved with the `RecordingStatus` object.\n   */\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  /**\n   * Sets a function to be called regularly with the `RecordingStatus` of the `Recording`.\n   *\n   * `onRecordingStatusUpdate` will be called when another call to the API for this recording completes (such as `prepareToRecordAsync()`,\n   * `startAsync()`, `getStatusAsync()`, or `stopAndUnloadAsync()`), and will also be called at regular intervals while the recording can record.\n   * Call `setProgressUpdateInterval()` to modify the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   *\n   * @param onRecordingStatusUpdate A function taking a single parameter `RecordingStatus`.\n   */\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  /**\n   * Sets the interval with which `onRecordingStatusUpdate` is called while the recording can record.\n   * See `setOnRecordingStatusUpdate` for details. This value defaults to 500 milliseconds.\n   * @param progressUpdateIntervalMillis The new interval between calls of `onRecordingStatusUpdate`.\n   */\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  /**\n   * Loads the recorder into memory and prepares it for recording. This must be called before calling `startAsync()`.\n   * This method can only be called if the `Recording` instance has never yet been prepared.\n   *\n   * @param options `RecordingOptions` for the recording, including sample rate, bitrate, channels, format, encoder, and extension.\n   * If no options are passed to `prepareToRecordAsync()`, the recorder will be created with options `Audio.RecordingOptionsPresets.LOW_QUALITY`.\n   *\n   * @return A `Promise` that is fulfilled when the recorder is loaded and prepared, or rejects if this failed. If another `Recording` exists\n   * in your experience that is currently prepared to record, the `Promise` will reject. If the `RecordingOptions` provided are invalid,\n   * the `Promise` will also reject. The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async prepareToRecordAsync(\n    options: RecordingOptions = RecordingOptionsPresets.LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  /**\n   * Returns a list of available recording inputs. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with an array of `RecordingInput` objects.\n   */\n  async getAvailableInputs(): Promise<RecordingInput[]> {\n    return ExponentAV.getAvailableInputs();\n  }\n\n  /**\n   * Returns the currently-selected recording input. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled with a `RecordingInput` object.\n   */\n  async getCurrentInput(): Promise<RecordingInput> {\n    return ExponentAV.getCurrentInput();\n  }\n\n  /**\n   * Sets the current recording input.\n   * @param inputUid The uid of a `RecordingInput`.\n   * @return A `Promise` that is resolved if successful or rejected if not.\n   */\n  async setInput(inputUid: string): Promise<void> {\n    return ExponentAV.setInput(inputUid);\n  }\n\n  /**\n   * Begins recording. This method can only be called if the `Recording` has been prepared.\n   * @return A `Promise` that is fulfilled when recording has begun, or rejects if recording could not be started.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  /**\n   * Pauses recording. This method can only be called if the `Recording` has been prepared.\n   *\n   * > This is only available on Android API version 24 and later.\n   *\n   * @return A `Promise` that is fulfilled when recording has paused, or rejects if recording could not be paused.\n   * If the Android API version is less than 24, the `Promise` will reject. The promise is resolved with the\n   * `RecordingStatus` of the recording.\n   */\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  /**\n   * Stops the recording and deallocates the recorder from memory. This reverts the `Recording` instance\n   * to an unprepared state, and another `Recording` instance must be created in order to record again.\n   * This method can only be called if the `Recording` has been prepared.\n   *\n   * > On Android this method may fail with `E_AUDIO_NODATA` when called too soon after `startAsync` and\n   * > no audio data has been recorded yet. In that case the recorded file will be invalid and should be discarded.\n   *\n   * @return A `Promise` that is fulfilled when recording has stopped, or rejects if recording could not be stopped.\n   * The promise is resolved with the `RecordingStatus` of the recording.\n   */\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  /**\n   * Gets the local URI of the `Recording`. Note that this will only succeed once the `Recording` is prepared\n   * to record. On web, this will not return the URI until the recording is finished.\n   * @return A `string` with the local URI of the `Recording`, or `null` if the `Recording` is not prepared\n   * to record (or, on Web, if the recording has not finished).\n   */\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /**\n   * @deprecated Use `createNewLoadedSoundAsync()` instead.\n   */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  /**\n   * Creates and loads a new `Sound` object to play back the `Recording`. Note that this will only succeed once the `Recording`\n   * is done recording and `stopAndUnloadAsync()` has been called.\n   *\n   * @param initialStatus The initial intended `PlaybackStatusToSet` of the sound, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. See the [AV documentation](/versions/latest/sdk/av) for details on `PlaybackStatusToSet`\n   * and the default initial playback status.\n   * @param onPlaybackStatusUpdate A function taking a single parameter `PlaybackStatus`. This value defaults to `null` if no parameter is passed.\n   * See the [AV documentation](/versions/latest/sdk/av) for details on the functionality provided by `onPlaybackStatusUpdate`\n   *\n   * @return A `Promise` that is rejected if creation failed, or fulfilled with the `SoundObject`.\n   */\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<SoundObject> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport { PermissionResponse, PermissionStatus, PermissionHookOptions };\n\nexport * from './RecordingConstants';\n\nexport * from './Recording.types';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}