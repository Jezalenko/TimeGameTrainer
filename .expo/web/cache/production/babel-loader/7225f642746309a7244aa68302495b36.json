{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _asyncToGenerator from\"@babel/runtime/helpers/asyncToGenerator\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import{Asset}from'expo-asset';import{Platform}from'expo-modules-core';import{PitchCorrectionQuality}from\"./AV.types\";export var _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS=500;export var _DEFAULT_INITIAL_PLAYBACK_STATUS={positionMillis:0,progressUpdateIntervalMillis:_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,shouldPlay:false,rate:1.0,shouldCorrectPitch:false,volume:1.0,audioPan:0,isMuted:false,isLooping:false};export function getNativeSourceFromSource(source){var uri=null;var overridingExtension=null;var headers;if(typeof source==='string'&&Platform.OS==='web'){return{uri:source,overridingExtension:overridingExtension,headers:headers};}var asset=_getAssetFromPlaybackSource(source);if(asset!=null){uri=asset.localUri||asset.uri;}else if(source!=null&&typeof source!=='number'&&'uri'in source&&typeof source.uri==='string'){uri=source.uri;}if(uri==null){return null;}if(source!=null&&typeof source!=='number'&&'overrideFileExtensionAndroid'in source&&typeof source.overrideFileExtensionAndroid==='string'){overridingExtension=source.overrideFileExtensionAndroid;}if(source!=null&&typeof source!=='number'&&'headers'in source&&typeof source.headers==='object'){headers=source.headers;}return{uri:uri,overridingExtension:overridingExtension,headers:headers};}function _getAssetFromPlaybackSource(source){if(source==null){return null;}var asset=null;if(typeof source==='number'){asset=Asset.fromModule(source);}else if(source instanceof Asset){asset=source;}return asset;}export function assertStatusValuesInBounds(status){if(typeof status.rate==='number'&&(status.rate<0||status.rate>32)){throw new RangeError('Rate value must be between 0.0 and 32.0');}if(typeof status.volume==='number'&&(status.volume<0||status.volume>1)){throw new RangeError('Volume value must be between 0.0 and 1.0');}if(typeof status.audioPan==='number'&&(status.audioPan<-1||status.audioPan>1)){throw new RangeError('Pan value must be between -1.0 and 1.0');}}export function getNativeSourceAndFullInitialStatusForLoadAsync(_x,_x2,_x3){return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this,arguments);}function _getNativeSourceAndFullInitialStatusForLoadAsync(){_getNativeSourceAndFullInitialStatusForLoadAsync=_asyncToGenerator(function*(source,initialStatus,downloadFirst){var fullInitialStatus=initialStatus==null?_DEFAULT_INITIAL_PLAYBACK_STATUS:_objectSpread(_objectSpread({},_DEFAULT_INITIAL_PLAYBACK_STATUS),initialStatus);assertStatusValuesInBounds(fullInitialStatus);if(typeof source==='string'&&Platform.OS==='web'){return{nativeSource:{uri:source,overridingExtension:null},fullInitialStatus:fullInitialStatus};}var asset=_getAssetFromPlaybackSource(source);if(downloadFirst&&asset){yield asset.downloadAsync();}var nativeSource=getNativeSourceFromSource(source);if(nativeSource===null){throw new Error(\"Cannot load an AV asset from a null playback source\");}if(asset&&asset.localUri){nativeSource.uri=asset.localUri;}return{nativeSource:nativeSource,fullInitialStatus:fullInitialStatus};});return _getNativeSourceAndFullInitialStatusForLoadAsync.apply(this,arguments);}export function getUnloadedStatus(){var error=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;return _objectSpread({isLoaded:false},error?{error:error}:null);}export var PlaybackMixin={playAsync:function(){var _playAsync=_asyncToGenerator(function*(){return this.setStatusAsync({shouldPlay:true});});function playAsync(){return _playAsync.apply(this,arguments);}return playAsync;}(),playFromPositionAsync:function(){var _playFromPositionAsync=_asyncToGenerator(function*(positionMillis){var tolerances=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return this.setStatusAsync({positionMillis:positionMillis,shouldPlay:true,seekMillisToleranceAfter:tolerances.toleranceMillisAfter,seekMillisToleranceBefore:tolerances.toleranceMillisBefore});});function playFromPositionAsync(_x4){return _playFromPositionAsync.apply(this,arguments);}return playFromPositionAsync;}(),pauseAsync:function(){var _pauseAsync=_asyncToGenerator(function*(){return this.setStatusAsync({shouldPlay:false});});function pauseAsync(){return _pauseAsync.apply(this,arguments);}return pauseAsync;}(),stopAsync:function(){var _stopAsync=_asyncToGenerator(function*(){return this.setStatusAsync({positionMillis:0,shouldPlay:false});});function stopAsync(){return _stopAsync.apply(this,arguments);}return stopAsync;}(),setPositionAsync:function(){var _setPositionAsync=_asyncToGenerator(function*(positionMillis){var tolerances=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return this.setStatusAsync({positionMillis:positionMillis,seekMillisToleranceAfter:tolerances.toleranceMillisAfter,seekMillisToleranceBefore:tolerances.toleranceMillisBefore});});function setPositionAsync(_x5){return _setPositionAsync.apply(this,arguments);}return setPositionAsync;}(),setRateAsync:function(){var _setRateAsync=_asyncToGenerator(function*(rate){var shouldCorrectPitch=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var pitchCorrectionQuality=arguments.length>2&&arguments[2]!==undefined?arguments[2]:PitchCorrectionQuality.Low;return this.setStatusAsync({rate:rate,shouldCorrectPitch:shouldCorrectPitch,pitchCorrectionQuality:pitchCorrectionQuality});});function setRateAsync(_x6){return _setRateAsync.apply(this,arguments);}return setRateAsync;}(),setVolumeAsync:function(){var _setVolumeAsync=_asyncToGenerator(function*(volume,audioPan){return this.setStatusAsync({volume:volume,audioPan:audioPan});});function setVolumeAsync(_x7,_x8){return _setVolumeAsync.apply(this,arguments);}return setVolumeAsync;}(),setIsMutedAsync:function(){var _setIsMutedAsync=_asyncToGenerator(function*(isMuted){return this.setStatusAsync({isMuted:isMuted});});function setIsMutedAsync(_x9){return _setIsMutedAsync.apply(this,arguments);}return setIsMutedAsync;}(),setIsLoopingAsync:function(){var _setIsLoopingAsync=_asyncToGenerator(function*(isLooping){return this.setStatusAsync({isLooping:isLooping});});function setIsLoopingAsync(_x10){return _setIsLoopingAsync.apply(this,arguments);}return setIsLoopingAsync;}(),setProgressUpdateIntervalAsync:function(){var _setProgressUpdateIntervalAsync=_asyncToGenerator(function*(progressUpdateIntervalMillis){return this.setStatusAsync({progressUpdateIntervalMillis:progressUpdateIntervalMillis});});function setProgressUpdateIntervalAsync(_x11){return _setProgressUpdateIntervalAsync.apply(this,arguments);}return setProgressUpdateIntervalAsync;}()};export*from\"./AV.types\";","map":{"version":3,"names":["Asset","Platform","PitchCorrectionQuality","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","_DEFAULT_INITIAL_PLAYBACK_STATUS","positionMillis","progressUpdateIntervalMillis","shouldPlay","rate","shouldCorrectPitch","volume","audioPan","isMuted","isLooping","getNativeSourceFromSource","source","uri","overridingExtension","headers","OS","asset","_getAssetFromPlaybackSource","localUri","overrideFileExtensionAndroid","fromModule","assertStatusValuesInBounds","status","RangeError","getNativeSourceAndFullInitialStatusForLoadAsync","_x","_x2","_x3","_getNativeSourceAndFullInitialStatusForLoadAsync","apply","arguments","_asyncToGenerator","initialStatus","downloadFirst","fullInitialStatus","_objectSpread","nativeSource","downloadAsync","Error","getUnloadedStatus","error","length","undefined","isLoaded","PlaybackMixin","playAsync","_playAsync","setStatusAsync","playFromPositionAsync","_playFromPositionAsync","tolerances","seekMillisToleranceAfter","toleranceMillisAfter","seekMillisToleranceBefore","toleranceMillisBefore","_x4","pauseAsync","_pauseAsync","stopAsync","_stopAsync","setPositionAsync","_setPositionAsync","_x5","setRateAsync","_setRateAsync","pitchCorrectionQuality","Low","_x6","setVolumeAsync","_setVolumeAsync","_x7","_x8","setIsMutedAsync","_setIsMutedAsync","_x9","setIsLoopingAsync","_setIsLoopingAsync","_x10","setProgressUpdateIntervalAsync","_setProgressUpdateIntervalAsync","_x11"],"sources":["../src/AV.ts"],"sourcesContent":["import { Asset } from 'expo-asset';\nimport { Platform } from 'expo-modules-core';\n\nimport {\n  AVPlaybackSource,\n  AVPlaybackNativeSource,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n  PitchCorrectionQuality,\n  AVPlaybackTolerance,\n} from './AV.types';\n\n// TODO add:\n//  disableFocusOnAndroid\n//  audio routes (at least did become noisy on android)\n//  pan\n//  pitch\n//  API to explicitly request audio focus / session\n//  API to select stream type on Android\n//  subtitles API\n\n/**\n * @hidden\n */\nexport const _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS: number = 500;\n\n// @needsAudit\n/**\n * The default initial `AVPlaybackStatusToSet` of all `Audio.Sound` objects and `Video` components is as follows:\n *\n * ```javascript\n * {\n *   progressUpdateIntervalMillis: 500,\n *   positionMillis: 0,\n *   shouldPlay: false,\n *   rate: 1.0,\n *   shouldCorrectPitch: false,\n *   volume: 1.0,\n *   isMuted: false,\n *   isLooping: false,\n * }\n * ```\n *\n * This default initial status can be overwritten by setting the optional `initialStatus` in `loadAsync()` or `Audio.Sound.createAsync()`.\n */\nexport const _DEFAULT_INITIAL_PLAYBACK_STATUS: AVPlaybackStatusToSet = {\n  positionMillis: 0,\n  progressUpdateIntervalMillis: _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  shouldPlay: false,\n  rate: 1.0,\n  shouldCorrectPitch: false,\n  volume: 1.0,\n  audioPan: 0,\n  isMuted: false,\n  isLooping: false,\n};\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getNativeSourceFromSource(\n  source?: AVPlaybackSource | null\n): AVPlaybackNativeSource | null {\n  let uri: string | null = null;\n  let overridingExtension: string | null = null;\n  let headers: AVPlaybackNativeSource['headers'];\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      uri: source,\n      overridingExtension,\n      headers,\n    };\n  }\n\n  const asset: Asset | null = _getAssetFromPlaybackSource(source);\n  if (asset != null) {\n    uri = asset.localUri || asset.uri;\n  } else if (\n    source != null &&\n    typeof source !== 'number' &&\n    'uri' in source &&\n    typeof source.uri === 'string'\n  ) {\n    uri = source.uri;\n  }\n\n  if (uri == null) {\n    return null;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'overrideFileExtensionAndroid' in source &&\n    typeof source.overrideFileExtensionAndroid === 'string'\n  ) {\n    overridingExtension = source.overrideFileExtensionAndroid;\n  }\n\n  if (\n    source != null &&\n    typeof source !== 'number' &&\n    'headers' in source &&\n    typeof source.headers === 'object'\n  ) {\n    headers = source.headers;\n  }\n  return { uri, overridingExtension, headers };\n}\n\nfunction _getAssetFromPlaybackSource(source?: AVPlaybackSource | null): Asset | null {\n  if (source == null) {\n    return null;\n  }\n\n  let asset: Asset | null = null;\n  if (typeof source === 'number') {\n    asset = Asset.fromModule(source);\n  } else if (source instanceof Asset) {\n    asset = source;\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function assertStatusValuesInBounds(status: AVPlaybackStatusToSet): void {\n  if (typeof status.rate === 'number' && (status.rate < 0 || status.rate > 32)) {\n    throw new RangeError('Rate value must be between 0.0 and 32.0');\n  }\n  if (typeof status.volume === 'number' && (status.volume < 0 || status.volume > 1)) {\n    throw new RangeError('Volume value must be between 0.0 and 1.0');\n  }\n  if (typeof status.audioPan === 'number' && (status.audioPan < -1 || status.audioPan > 1)) {\n    throw new RangeError('Pan value must be between -1.0 and 1.0');\n  }\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport async function getNativeSourceAndFullInitialStatusForLoadAsync(\n  source: AVPlaybackSource | null,\n  initialStatus: AVPlaybackStatusToSet | null,\n  downloadFirst: boolean\n): Promise<{\n  nativeSource: AVPlaybackNativeSource;\n  fullInitialStatus: AVPlaybackStatusToSet;\n}> {\n  // Get the full initial status\n  const fullInitialStatus: AVPlaybackStatusToSet =\n    initialStatus == null\n      ? _DEFAULT_INITIAL_PLAYBACK_STATUS\n      : {\n          ..._DEFAULT_INITIAL_PLAYBACK_STATUS,\n          ...initialStatus,\n        };\n  assertStatusValuesInBounds(fullInitialStatus);\n\n  if (typeof source === 'string' && Platform.OS === 'web') {\n    return {\n      nativeSource: {\n        uri: source,\n        overridingExtension: null,\n      },\n      fullInitialStatus,\n    };\n  }\n\n  // Download first if necessary.\n  const asset = _getAssetFromPlaybackSource(source);\n  if (downloadFirst && asset) {\n    // TODO we can download remote uri too once @nikki93 has integrated this into Asset\n    await asset.downloadAsync();\n  }\n\n  // Get the native source\n  const nativeSource: AVPlaybackNativeSource | null = getNativeSourceFromSource(source);\n\n  if (nativeSource === null) {\n    throw new Error(`Cannot load an AV asset from a null playback source`);\n  }\n\n  // If asset has been downloaded use the localUri\n  if (asset && asset.localUri) {\n    nativeSource.uri = asset.localUri;\n  }\n\n  return { nativeSource, fullInitialStatus };\n}\n\n// @needsAudit\n/**\n * @hidden\n */\nexport function getUnloadedStatus(error: string | null = null): AVPlaybackStatus {\n  return {\n    isLoaded: false,\n    ...(error ? { error } : null),\n  };\n}\n\n// @needsAudit\nexport interface AV {\n  /**\n   * Sets a new `AVPlaybackStatusToSet` on the `playbackObject`. This method can only be called if the media has been loaded.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed. See below for details on `AVPlaybackStatus`.\n   */\n  setStatusAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * Gets the `AVPlaybackStatus` of the `playbackObject`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject`.\n   */\n  getStatusAsync(): Promise<AVPlaybackStatus>;\n}\n\n// @needsAudit\n/**\n * On the `playbackObject` reference, the following API is provided.\n */\nexport interface Playback extends AV {\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   */\n  playAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Loads the media from `source` into memory and prepares it for playing. This must be called before calling `setStatusAsync()`\n   * or any of the convenience set status methods. This method can only be called if the `playbackObject` is in an unloaded state.\n   * @param source The source of the media.\n   * @param initialStatus The initial intended `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the default initial playback status.\n   * This value defaults to `{}` if no parameter is passed. For more information see the details on `AVPlaybackStatusToSet` type\n   * and the default initial playback status.\n   * @param downloadAsync If set to `true`, the system will attempt to download the resource to the device before loading.\n   * This value defaults to `true`. Note that at the moment, this will only work for `source`s of the form `require('path/to/file')` or `Asset` objects.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is loaded, or rejects if loading failed.\n   * The `Promise` will also reject if the `playbackObject` was already loaded. See below for details on `AVPlaybackStatus`.\n   */\n  loadAsync(\n    source: AVPlaybackSource,\n    initialStatus?: AVPlaybackStatusToSet,\n    downloadAsync?: boolean\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * Unloads the media from memory. `loadAsync()` must be called again in order to be able to play the media.\n   * > This cleanup function will be automatically called in the `Video` component's `componentWillUnmount`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once it is unloaded, or rejects if unloading failed.\n   */\n  unloadAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: true, positionMillis, seekMillisToleranceAfter: tolerances.seekMillisToleranceAfter, seekMillisToleranceBefore: tolerances.seekMillisToleranceBefore })`.\n   *\n   * Playback may not start immediately after calling this function for reasons such as buffering. Make sure to update your UI based\n   * on the `isPlaying` and `isBuffering` properties of the `AVPlaybackStatus`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  playFromPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false })`.\n   */\n  pauseAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ shouldPlay: false, positionMillis: 0 })`.\n   */\n  stopAsync(): Promise<AVPlaybackStatus>;\n\n  /**\n   * Replays the playback item. When using `playFromPositionAsync(0)` the item is seeked to the position at `0 ms`.\n   * On iOS this method uses internal implementation of the player and is able to play the item from the beginning immediately.\n   * @param status The new `AVPlaybackStatusToSet` of the `playbackObject`, whose values will override the current playback status.\n   * `positionMillis` and `shouldPlay` properties will be overridden with respectively `0` and `true`.\n   * @return A `Promise` that is fulfilled with the `AVPlaybackStatus` of the `playbackObject` once the new status has been set successfully,\n   * or rejects if setting the new status failed.\n   */\n  replayAsync(status: AVPlaybackStatusToSet): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ positionMillis })`.\n   * @param positionMillis The desired position of playback in milliseconds.\n   * @param tolerances The tolerances are used only on iOS ([more details](#what-is-seek-tolerance-and-why-would)).\n   */\n  setPositionAsync(\n    positionMillis: number,\n    tolerances?: AVPlaybackTolerance\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ rate, shouldCorrectPitch, pitchCorrectionQuality })`.\n   * @param rate The desired playback rate of the media. This value must be between `0.0` and `32.0`. Only available on Android API version 23 and later and iOS.\n   * @param shouldCorrectPitch A boolean describing if we should correct the pitch for a changed rate. If set to `true`, the pitch of the audio will be corrected\n   * (so a rate different than `1.0` will timestretch the audio).\n   * @param pitchCorrectionQuality iOS time pitch algorithm setting, defaults to `Audio.PitchCorrectionQuality.Low`.\n   */\n  setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean,\n    pitchCorrectionQuality?: PitchCorrectionQuality\n  ): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ volume, audioPan })`.\n   * Note: `audioPan` is currently only supported on Android using `androidImplementation: 'MediaPlayer'`\n   * @param volume A number between `0.0` (silence) and `1.0` (maximum volume).\n   * @param audioPan A number between `-1.0` (full left) and `1.0` (full right).\n   */\n  setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isMuted })`.\n   * @param isMuted A boolean describing if the audio of this media should be muted.\n   */\n  setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ isLooping })`.\n   * @param isLooping A boolean describing if the media should play once (`false`) or loop indefinitely (`true`).\n   */\n  setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus>;\n\n  /**\n   * This is equivalent to `playbackObject.setStatusAsync({ progressUpdateIntervalMillis })`.\n   * @param progressUpdateIntervalMillis The new minimum interval in milliseconds between calls of `onPlaybackStatusUpdate`.\n   * See `setOnPlaybackStatusUpdate()` for details.\n   */\n  setProgressUpdateIntervalAsync(progressUpdateIntervalMillis: number): Promise<AVPlaybackStatus>;\n}\n\n/**\n * @hidden\n * A mixin that defines common playback methods for A/V classes, so they implement the `Playback`\n * interface.\n */\nexport const PlaybackMixin = {\n  async playAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: true });\n  },\n\n  async playFromPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      shouldPlay: true,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async pauseAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ shouldPlay: false });\n  },\n\n  async stopAsync(): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ positionMillis: 0, shouldPlay: false });\n  },\n\n  async setPositionAsync(\n    positionMillis: number,\n    tolerances: AVPlaybackTolerance = {}\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      positionMillis,\n      seekMillisToleranceAfter: tolerances.toleranceMillisAfter,\n      seekMillisToleranceBefore: tolerances.toleranceMillisBefore,\n    });\n  },\n\n  async setRateAsync(\n    rate: number,\n    shouldCorrectPitch: boolean = false,\n    pitchCorrectionQuality: PitchCorrectionQuality = PitchCorrectionQuality.Low\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({\n      rate,\n      shouldCorrectPitch,\n      pitchCorrectionQuality,\n    });\n  },\n\n  async setVolumeAsync(volume: number, audioPan?: number): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ volume, audioPan });\n  },\n\n  async setIsMutedAsync(isMuted: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isMuted });\n  },\n\n  async setIsLoopingAsync(isLooping: boolean): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ isLooping });\n  },\n\n  async setProgressUpdateIntervalAsync(\n    progressUpdateIntervalMillis: number\n  ): Promise<AVPlaybackStatus> {\n    return (this as any as Playback).setStatusAsync({ progressUpdateIntervalMillis });\n  },\n};\n\nexport * from './AV.types';\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}